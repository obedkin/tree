# Содержание


 * Описание
 * Установка
 * Параметры
    * Обязательные
    * Опциональные
        * Выборка
        * Раскрытое дерево
 * Список
 
        
 * Логика
 * Добавление
 * Копирование
 * Удаление
 * Поиск
 * Наследование
 * Переопределение
 * Пример

# Описание

 * Название модуля: GLOBAL Tree
 * Дата создания: 27.02.2015
 * Описание: Модуль для отображения материалов виде древовидной структуры данных


# Параметры
## Выборка
Для того чтобы можно было выбирать элементы дерева с помощью галочек, необходимо указать следующие параметры

* **[top][check][title]** - Название около кнопки, если оно показывается. Например: **Выбрать**
* **[top][check][description]** - Описание для ссылки при наведении Например **Выбрать элементы дерева**
* **[top][check][out_selector]** - Селектор в dom-дереве документа формата jQuery (#id или .class). Например: **#tree** или **.tree** 

### Пример
```php
$options = array(
    'admin' => TRUE,
    'top' => array(
      'buttons' => array(
        'add',
        'close',
        'open',
        'sort',
        'check' => array(
          'title' => 'Выбрать',
          'description' => 'Выбрать элементы дерева',
          'out_selector' => '.global-tree-input'
        )
      ),
      'show_title' => FALSE,
    ),
    'root_show' => TRUE,
    'target_id' => arg(1),
    'url' => 'category',
    'suffix' => 'edit'
    'entity_type' => 'node',
    'bundle' => 'category',
    'parent_field' => 'field_parent',
    'order' => array('field' => 'field_weight', 'type' => 'ASC'),
    'entity_type_id' => 'target_id',
  ); 
  $tree = new GlobalTree($options);
  $tree = $tree->get_tree_html()
```
### Результат

![Дерево с элементами выбора](https://gitlab.grcc.ru/files/note/13808/screenshot-drupal_2016-02-09_15-46-59.png "Дерево с элементами выбора")


## Раскрытое дерево
Для того, чтобы при загрузке страницы дерево было изначально раскрытым необходимо передать параметр
 
* [all_open] = TRUE

Если помимо **all_open** ещё есть и параметр **target_id**, то будет раскрыт только та часть дерева, на которую указывает
**target_id**

### Пример
```php
$options = array(
    'entity_type' => 'node',
    'bundle' => 'category',
    'parent_field' => 'field_parent',
    'order' => array('field' => 'field_weight', 'type' => 'ASC'),
    'entity_type_id' => 'target_id',
    'all_open'=> TRUE,
  ); 
  $tree = new GlobalTree($options);
  $tree = $tree->get_tree_html()
```

### Результат
![Полностью раскрытое дерево при загрузке](https://gitlab.grcc.ru/files/note/13865/screenshot-drupal_2016-02-18_12-47-32.png "Полностью раскрытое дерево при загрузке")


# Список
Для получение линейного списка, который обычно используется элементах формы SELECT, можно использовать следующую
функцию **get_tree_list**

## Список. Пример
```php
$list = new GlobalTree(array(
    'entity_type' => 'node',
    'bundle' => 'out_template',
    'parent_field' => 'field_ln_out_template',
  ));
 $tree->get_tree_list();
 ```
 
## Cписок. Результат
 
![Полностью раскрытое дерево при загрузке](https://gitlab.grcc.ru/Global/global_tree/uploads/23bbee0d597b9963a781d86074652599/global_tree_list.png "Список")
 


 
 
 
# Инструкция, которая ниже будет переписываться в рабочем порядке
---------------------







Установка
---------------------
 * Для использования данного модуля внутри другого проекта необходимо выполнить команду
   git submodule add git@gitlab.global.ru:drupal/global_tree.git global_tree
   Будет создана директория global_tree и в неё будет импортирован код модуля "GLOBAL Tree"
 * Для корректной работы данного модуля необходимо подключить все его зависимости, указанные в файле
   .info. Например модуль "node_reference" не нужен в линейной структуре дерева, но
   без него невозможна работа по указанию дочерних и связанных объектов и сущностей.
   Или же модуль 'path_auto', который не пригодится в легкой комплектации, но просто необходим
   для формирования чпу-сcылок по параметру 'options[url]'
 * После того, как зависимости успешно установлены и модуль подключен, можно приступать к формированию
   простейшего дерева, при условии что в базе данных имеются корректные данные для его построения.

   Пример:
       $options = array(
         'entity_type' => 'node',
         'bundle' => 'category',
       );
       $tree = new GlobalTree($options);
       $out = $tree->get_tree_html();
       return $out


Параметры
---------------------


Параметры. Обязательные
--------------------------

 * entity_type  [string]        Тип объектов, представленных в дереве.
                                Пример: node
 * bundle       [string]        Вид объектов для выборки из БД
                                Пример: news, article, category и т.д.


Параметры. Опциональные
--------------------------
 * entity_type_id [string]      Наименования ID типа сущности поля
                                По умолчанию: вычисляется, в зависимости от entity_type
                                для node -> nid,
                                для taxonomy -> tid
                                Но можно передать принудительно, например для entity_reference -> target_id
                                Это применяется в том случае, если задается поле типа entity_references

 * parent_field     [string]    Наименование поля, по которому проходит связь между родительским и дочерним элементами
                                дерева.
                                По умолчанию для NODE: NULL, для терминов таксономии по встроенному полю PARENT

 * admin      [boolean|array]   Добавление элементов управления деревом. Возможны 2 режима: просмотр и администрирование
                                Возможные функции: добавление, удаление, редактирование, сортировка
                                Возможность сортировки доступна только том случае, если переданы поля
                                веса и род.связи, т.е.: parent_field и order[field]
                                По умолчанию: FALSE
                                Полная админка: admin = TRUE
                                Админка с ограничением admin = array('add','delete')
                                Возможные значения: add, edit, delete, copy

 * order                        Пример: order=>array('field'=>'field_weight','type'=>'ASC')
                                Замечание: Если указана данная опция и присутствуют элементы с незаполненными
                                данными по полю "вес", то они не попадают в выборку "fieldOrderBy" и
                                соответственно не будут отображаться в дереве
    * field         [string]    Наименование поля, по которому происходит сортировка. Если поле не передано
                                то для NODE сортировка происходит по названию А->Я, а для терминов таксономии
                                по встроенному полю WEIGHT
                                По умолчанию: title
    * type          [string]    Тип сортировки (ASC или DESC).
                                По умолчанию: ASC

 * root_id     [null|int|array] ID корневого элемента, начиная с которого идет построение дерева
                                Если ROOT_ID не передан, то построение начинается с корневых
                                элементов, у которых нет родителя. Если ROOT_ID передан, отображается
                                сам объект с данным ID, а также его непосредственные потомки.
                                Если передан массив из ROOT_ID, то строится многокорневое дерево,
                                в первую очередь из объектов массива ROOT_ID и далее их непосредственных
                                потомков первой линии.
                                По умолчанию: NULL

 * root_show        [boolean]   Показываем корень дерева, если он есть. По умолчанию TRUE для многокорневых деревьев

 * top
    buttons         [array]     Какие кнопки показываем вверху дерева (add,show,close и т.д.)
                                add   - добавить корневой элемент в дерево
                                open  - раскрыть всё дерево
                                close - свернуть всё дерево
                                sort  - сортировка
                                Если включен режим "ADMIN" и отсутствует параметр "TOP_BUTTON" то отображаются
                                все кнопке, если есть параметр "TOP_BUTTON", то только те кнопки, которые там перечислены
                                Дополнительные условия для кнопки "SORT", должно быть передано поле для связи с родителями
                                и поле сортировки по весу.
                                По умолчанию: array(close,open)
    show_title      [boolean]   Показывать названия кнопок вверху или нет
                                По умолчанию: ДА (TRUE)

 * url              [string]    SEO-url который участвует в формировании ссылок вида site/[URL]/id (Пример: parsek/vs/100/)
 * suffix           [string]    SEO-url который участвует в формировании ссылок вида site/id/suffix/ (Пример: parsek/vs/100/edit)

 * target_id        [int]       ID текущего элемента, который должен быть активен в дереве

 * function_form_add[string]    Название функции, которая будет вызываться при построение формы добавления элементов в дерево

 * add
    * after_submit[string]      Название функции, которая будет вызываться после выполнения submit_ajax_callback.
                                Функция должна возвращать массив commands (http://xandeadx.ru/blog/drupal/492)
                                Например в "Вооруженных силах" проекта "Парсек", будет происходить ajax-обновление формы
                                Входящий параметр: id нового созданного элемента
                                Например: 'add' => array('after_submit'=>'parsek_vs_add_after_ajax_submit')

 * delete                       По умолчанию: node_delete() для объекта и всех его потомков

    * function        [string]  Название функции удаления, которая должна будет вызываться при удалении элемента дерева
                                Функция удаления на входе должна иметь 1 обязательный параметр: ID удаляемого объекта
                                По умолчанию: node_delete()
    * recursive       [boolean] Тип рекурсивного удаления вместе с потомками. TRUE - удалять и потомков объекта дерева
                                FALSE - удаляется только сам объект дерева.
                                По умолчанию: TRUE

 * attributes_field [string]    Наименование поля, по которому связаны атрибуты с элементом дерева

 * attributes_bundle[string]    Тип атрибутов, кол-во которых можно выводить около названия

 * search           [boolean]   Возможность поиска по дереву. Работает в связке с параметру "URL"
                                По умолчанию: FALSE

Логика
--------------------------
1. После создания объекта класса "GlobalTree" и для получения готового html-дерева из стилизованного маркированного
   списка, необходимо использовать метод "get_tree_html", который возвращает html-структуру дерева. Данный метод
   может быть переопределен в дочерних классах на свое усмотрение. При построении дерева используется
   стандартная Drupal-функция: "theme_item_list" (https://api.drupal.org/api/drupal/includes!theme.inc/function/theme_item_list/7)
2. Исходные данные для формирования элементов дерева получаются с помощью метода: "get_tree_res()". Где происходит
   выборка [EntityFieldQuery] необходимых элементов, согласно "options", переданных в конструктор данного класса.
   Данный метод может быть переопределен в дочерних классах на свое усмотрение. Также в данном методе сразу определяется
   кол-во дочерних объектов для элементов 1-ого уровня. Это необходимо для стилизации отображения элементов дерева, которые
   имеют потомков или не имеют таковых. В результате метод возвращает массив элементов, имеющих следующие поля:
    array ( nid             => ID,
            title           => TEXT,
            child_count     => NUMBER
    )
3. После формирования массива с исходными данными происходит формирование элементов списка методом "get_tree_items".
   Один элемент списка формируется с помощью метода "get_tree_item". В качестве параметра данному методу передается
   элемент массива, сформированного на шаге [2]. При формировании элемента можно задать стиль его отображения в общем
   дереве элементов, а также опционально определить отображение элементов управления: "Добавить", "Удалить" и "Копировать"
4. Для загрузки корневых элементов (элементов, у которых нет родителей) рядом со всеми дочерними классами
   необходимо переопределить функцию: global_table_query_[URL]_has_not_parent_alter()
   Пример для ВС:
     function global_table_query_vs_has_not_parent_alter(QueryAlterableInterface $query) {
      $query->leftJoin('field_data_field_ln_parent', 'p', "node.nid = p.entity_id AND p.bundle = 'vs'");
      $query->isNull('p.field_ln_parent_nid');
    }
   Т.е. в функции идет связь по типу "bundle" и названию поля, по которому дочерние подчиняются родительским
5. После того, как дерево было успешно построено при загрузке страницы, можно динамически подгружать содержимое
   его элементов. Подгрузка содержимого (раскрытие ветвей) происходит с помощью функции "l/ajax". Отправляется дополнительный
   запрос на сервер и формируется новый объект класса GlobalTree, согласно пункта [1].


Добавление
--------------------------

Добавление элементов в дерево может происходить как на уровне корневых элементов, не имеющих родителей, так и для уже существующих
элементов и объектов дерева. При добавлении элементов в дерево открывается форма добавления, которая передается через опциональный
параметр:
 * function_form_add
Если название функции не передано или передано название несуществующей функции, то вызывается стандартная функция модуля:
 * global_tree_form_add()
Функция отвечает за построение формы добавления новых элементов. В функции по умолчанию указано только название нового объекта.
Внутри функции вешается стандартный CALLBACK на функцию:
 * global_tree_form_add_ajax_callback()
Данный CALLBACK, скорее всего, у вас не будет необходимости переопределять, т.к. внутри него вызывается функция
 * add()
вашего дочернего класса. Внутри этой функции вы можете делать при создании элемента любые операции с вашим новым элементом.
Далее внутри CALLBACK'а идёт перестроение всего или только части дерева. В случае переопределения CALLBACK'a и вносимых
изменения в глобальную структуру дерева, вам нужно будет править и ваш CALLBACK.


Копирование
--------------------------


Удаление
--------------------------


Поиск
--------------------------
Для отображения формы поиска необходимы параметры "SEARCH" и "URL". URL в частности нужен для перехода
на страницу элемента дерева, который был выбран из выпадающего списка. Поиск с автодополнением начинает
работать, когда пользователь ввёл 2 и более символов. В консоли можно наблюдать какие запросы в этот
момент отравляются на сервер и какие возвращаются обратно. Функция поиска лежит в отдельном inc-файле
(global_tree_search.inc) и называется "global_tree_search_callback". Обмен происходит в JSON-формате.
После того, как получены данные от сервера, удовлетворяющие условиям поиска, строится выпадающий список,
содержащий не более 10 позиций. Если пользователь выбирает любой элемент из выпадающего списка, то
происходит redirect на страницу вида site/options[url]/object_id и данный элемент в дереве помечается
как активный, а в строке поиска при загрузке страницы будет выведен TITLE активного элемента.
Если происходит клик по странице вне области выпадающего списка, то список пропадает.


Наследование
--------------------------
Подгрузка файлов классов просходит в момент инициализации модуля в хуке init(). Но если есть необходимость
переопределения своего класса, зависимого от GlobalTree, то необходимо побеспокоиться о предварительной
загрузке родительского класса внутри дочернего.
Пример:
        module_load_include('inc', 'global_tree','inc/global_tree');
        class MyClassTree extends GlobalTree {
            ...
        }


Переопределение
--------------------------
Всем методы класса, которые имеют тип видимости PUBLIC или PROTECTED могут быть переопределены внутри дочерних
 классов, унаследованных от мастер-класса GlobalTree.
 Пример:  public function get_search_html(){}
          Метод который участвует в формировании строки поиска. По умолчанию внутри data-параметров
          храняться 2 типа опций: "entity_type" и "bundle", которые участвуют в формировании ajax-запроса
          на получение данных из БД. Под свои нужны можно сужать область поиска вводя доп.параметры:
          например статус, область видимости, категория и т.д.
          На выходе должан получиться строка следующего типа: entity_type=node&bundle=category&field_country_id=10& т.д.
          Т.е. ввиде ключа необходимо передавать параметры ключа и значения, которые будут добавлены к условиям поиска
            $query->fieldCondition($key, 'nid', $value, '=');

          Если перед значением поставить знак нижнего подчёркивания _
          то условие будет выглядить следующим образом:
            $query->fieldCondition($key, 'value', substr($value,1));

          Пример data-options для поиска Вооруженных сил в проекте Parsek:
          data-options="entity_type=node&bundle=vs&field_ltx_country=689&field_ltx_dict_vs_type=557&field_is_main=_1"


Примеры
--------------------------

 * Самое простое дерево только с обязательными параметрами
   $options = array(
        'entity_type' => 'node',
        'bundle' => 'category',
   );
   $tree = new GlobalTree($options);
   $out = $tree->get_tree_html();

 * Сложное дерево, с админкой, поиском и сортировкой
   $nid = arg(1);
   $options = array(
         'entity_type' => 'node',
         'bundle' => 'category',
         'parent_field' => 'field_parent',
         'admin' => TRUE,
         'order' => array('field'=>'field_weight','type'=>'ASC'),
         'url'=>'category',
         'target_id'=>$nid,
         'search'=>TRUE
       );
   $tree = new GlobalTree($options);
   $out = $tree->get_tree_html();
   
 * Пример дерева с разными параметрами
   $options = array(
       'admin' => TRUE,
       'top' => array(
         'buttons' => array('add', 'close', 'open'),
         'show_title' => FALSE
       ),
       'root_show' => TRUE,
       'root_add' => TRUE,
       'top_button' => array('add', 'close', 'open'),
       'target_id' => arg(1),
       'url' => 'category',
       'entity_type' => 'node',
       'bundle' => 'category',
       'parent_field' => 'field_parent',
       'order' => array('field' => 'field_weight', 'type' => 'ASC'),
       'entity_type_id' => 'target_id',
       'style' => 'admin'
     );
     $tree = new GlobalTree($options);
     return $tree->get_tree_html();
